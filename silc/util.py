import os
from rdkit.Chem import AllChem

def clean_PDBQT(pdbqt_file):
    '''
    Remove the charge and element in PDBQT file written by AutoDock
    '''
    new_l = []
    new_file = pdbqt_file[:-4].split('/')[-1] + "_ADcleaned.pdb"

    with open(pdbqt_file, "r") as f:
        for l in f:
            new_l.append(l[:66] + "\n")

    with open(new_file, "w") as f:
        f.writelines(new_l)

    return new_file

def gen_mol_from_pdb_and_smiles(pdb_file, smiles, hydrogen=False):
    '''
    Generate molecule with coordinate from PDB and correct bond order and aromaticity from SMILES.
    https://github.com/rdkit/rdkit/issues/1031

    This is useful when converting the PDBQT generated by AutoDock to sanitized molecule (with correct
    aromaticity)

    return rdkit molecule
    '''
    mol_template = AllChem.MolFromSmiles(smiles)
    mol = AllChem.MolFromPDBFile(pdb_file)
    mol = AllChem.AssignBondOrdersFromTemplate(mol_template, mol)
    if hydrogen:
        mol_with_hydrogens = AllChem.AddHs(mol)
        mol_with_hydrogens = AllChem.ConstrainedEmbed(mol_with_hydrogens, mol)
        return mol_with_hydrogens
    else:
        return mol

def gen_mol_from_smiles(smiles, hydrogen=False):
    '''
    Generate a molecule with given smiles, and optimize the 3D structure.
    Hydrogen can be added optionally.

    Return rdkit molecule
    '''
    mol = AllChem.MolFromSmiles(smiles)
    if hydrogen:
        mol = AllChem.AddHs(mol)
    rtn = AllChem.EmbedMolecule(mol)
    if rtn == -1:    # fail to generate conformer by AllChem.EmbedMolecule
        AllChem.Compute2DCoords(mol)
    AllChem.MMFFOptimizeMolecule(mol)
    return mol

def expand_substructure(mol, core, expand_iteration=1):
    '''
    Find the substructure from mol that matches core, then expand it to n bonded neighbors.
    n is set by expand_iteration


    Return rdkit molecule
    '''
    if expand_iteration == 0:
        return AllChem.Mol(core)

    if expand_iteration < 0:
        raise RuntimeError("cannot have negative iteration number")

    if not mol.HasSubstructMatch(core):
        raise RuntimeError("Not match found")

    match = mol.GetSubstructMatches(core)
    if len(match) > 1:
        raise RuntimeError("More than one substructure matched")

    # Add the atoms from the matched substructure and their 1st neighbors
    core_atom_indices = list(match[0])
    keep_atom_indices = list(match[0])
    for atom_idx in core_atom_indices:
        atom = mol.GetAtomWithIdx(atom_idx)
        for neighbor in atom.GetNeighbors():
            neighbor_idx = neighbor.GetIdx()
            if neighbor_idx not in keep_atom_indices:
                keep_atom_indices.append(neighbor_idx)

    # Initialize a new empty molecule to store the expanded substructure
    expanded_core = AllChem.RWMol(mol)
    expanded_core.BeginBatchEdit()
    for atom in expanded_core.GetAtoms():
        atom_idx = atom.GetIdx()
        if atom_idx not in keep_atom_indices:
            expanded_core.RemoveAtom(atom_idx)
    expanded_core.CommitBatchEdit()

    expand_iteration -= 1
    return expand_substructure(mol, expanded_core, expand_iteration)

def align_to_substructure(mol, core, stretch=False, stretch_ratio_min=0.7, stretch_ratio_max=0.8):
    '''
    Align a molecule to a core substructure.
    Optionally stretch the molecule between chain ends to obtain extended conformation.

    core must have at least one conformer
    '''
    match = mol.GetSubstructMatch(core)
    mol = AllChem.ConstrainedEmbed(mol, core, randomseed=123, maxAttempts=100000)
    mp = AllChem.MMFFGetMoleculeProperties(mol, mmffVariant='MMFF94')
    ff = AllChem.MMFFGetMoleculeForceField(mol, mp)

    if stretch:
        # Find chain end
        chain_end_atom_idx = []

        # Iterate through the atoms in the molecule
        for atom in mol.GetAtoms():
            # Check if the atom is connected to only one other atom (chain end)
            if atom.GetDegree() == 1:
                chain_end_atom_idx.append(atom.GetIdx())

        # calculate the topological distance matrix, to get the number of bonds between chain ends
        dm = AllChem.GetDistanceMatrix(mol)
        # for each pair of chain ends, add a distance constrain
        for atomi in chain_end_atom_idx:
            for atomj in chain_end_atom_idx:
                if atomi > atomj:
                    distance = dm[atomi,atomj]
                    ### force chain ends to be far away from each other
                    ff.MMFFAddDistanceConstraint(atomi, atomj, stretch, distance*stretch_ratio_min, distance*stretch_ratio_max, 10)
        # constrain the motion of the core part
        for atom_idx in match:
            ff.MMFFAddPositionConstraint(atom_idx, 0.01,200)

        ff.Minimize(maxIts=10000)

    return mol

def optimize_complex(receptor, ligand_list, ligand_core_list):
    '''
    Use MMFF to optimize the complex structure, while keeping the receptor rigid.
    '''
    mols = [receptor] + ligand_list
    complex = AllChem.CombineMols(mols[0], mols[1])
    for i in range(2,len(mols)):
        complex = AllChem.CombineMols(complex, mols[i])
    match = complex.GetSubstructMatch(receptor)
    mp = AllChem.MMFFGetMoleculeProperties(complex, mmffVariant='MMFF94')
    ff = AllChem.MMFFGetMoleculeForceField(complex, mp)
    for atom_idx in match:
        ff.MMFFAddPositionConstraint(atom_idx, 0.01,200)
    for i in range(len(ligand_core_list)):
        matches = complex.GetSubstructMatches(ligand_core_list[i])
        for match in matches:
            for atom_idx in match:
                ff.MMFFAddPositionConstraint(atom_idx, 0.01,200)
    ff.Minimize(maxIts=10000)
    return complex
